<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chapitre 2 : Architecture du processeur 8086">
    <title>Chapitre 2 : Architecture 8086 - Learn2succeed</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/main.css">
    <link rel="stylesheet" href="../../../css/components.css">
    <link rel="stylesheet" href="../../../css/courses.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
</head>

<body>
    <a href="#main-content" class="skip-link">Aller au contenu principal</a>

    <header class="site-header">
        <div class="container">
            <a href="../../../index.html" class="site-logo"><span>üìö</span><span>Learn2succeed</span></a>
            <button class="menu-toggle" aria-label="Menu" aria-expanded="false">‚ò∞</button>
            <nav class="main-nav">
                <a href="../../../index.html">Accueil</a>
                <a href="../../../dashboard.html">Mon tableau de bord</a>
                <a href="../../../search.html">Rechercher</a>
            </nav>
        </div>
    </header>

    <main id="main-content">
        <div class="container-fluid">
            <div class="row">
                <aside class="col-lg-3 d-none d-lg-block" style="padding: var(--spacing-md);">
                    <div class="course-sidebar">
                        <h3>Cours Assembleur 8086</h3>
                        <ul class="chapter-list" id="chapter-list"></ul>
                    </div>
                </aside>

                <article class="col-lg-9">
                    <div class="container-reading section-sm">
                        <nav aria-label="Fil d'Ariane">
                            <ol class="breadcrumb">
                                <li class="breadcrumb-item"><a href="../../../index.html">Accueil</a></li>
                                <li class="breadcrumb-item"><a href="index.html">Cours Assembleur 8086</a></li>
                                <li class="breadcrumb-item active">Chapitre 2 : Architecture</li>
                            </ol>
                        </nav>

                        <header class="mb-5">
                            <span class="badge badge-primary mb-2">Chapitre 2</span>
                            <h1 class="mb-3">Architecture du processeur 8086</h1>
                            <p class="text-lg text-secondary">
                                Comprenez l'architecture interne du Intel 8086 : bus 16-bit, unit√© d'ex√©cution,
                                segmentation m√©moire et pipeline.
                            </p>
                            <p class="text-sm text-muted">‚è±Ô∏è Dur√©e estim√©e : 2h</p>
                        </header>

                        <nav class="chapter-nav">
                            <a href="ch01-introduction.html" class="chapter-nav-btn">‚Üê Pr√©c√©dent : Introduction</a>
                            <a href="ch03-registres.html" class="chapter-nav-btn">Suivant : Registres 16-bit ‚Üí</a>
                        </nav>

                        <section class="chapter-content">
                            <h2>Le processeur Intel 8086</h2>

                            <p>
                                Lanc√© en 1978, le <strong>Intel 8086</strong> est le premier processeur 16-bit de la
                                famille x86. Il contient <strong>29 000 transistors</strong> et peut fonctionner jusqu'√†
                                <strong>10 MHz</strong>.
                            </p>

                            <div class="alert alert-info">
                                <h4>üìä Caract√©ristiques principales</h4>
                                <ul>
                                    <li><strong>Architecture</strong> : 16-bit</li>
                                    <li><strong>Bus de donn√©es</strong> : 16-bit (2 octets √† la fois)</li>
                                    <li><strong>Bus d'adresses</strong> : 20-bit (1 MB de m√©moire adressable)</li>
                                    <li><strong>Fr√©quence</strong> : 5-10 MHz</li>
                                    <li><strong>Registres</strong> : 14 registres 16-bit</li>
                                </ul>
                            </div>

                            <h2>Architecture interne</h2>

                            <p>Le 8086 utilise une architecture √† <strong>2 unit√©s</strong> qui travaillent en parall√®le
                                :</p>

                            <h3>1. Unit√© d'Interface Bus (BIU)</h3>
                            <p>G√®re la communication avec la m√©moire et les p√©riph√©riques :</p>
                            <ul>
                                <li>Lecture/√©criture m√©moire</li>
                                <li>Acc√®s aux ports I/O</li>
                                <li>Pr√©-chargement des instructions (queue)</li>
                                <li>Calcul des adresses physiques</li>
                            </ul>

                            <h3>2. Unit√© d'Ex√©cution (EU)</h3>
                            <p>Ex√©cute les instructions :</p>
                            <ul>
                                <li>D√©codage des instructions</li>
                                <li>Op√©rations arithm√©tiques et logiques (ALU)</li>
                                <li>Gestion des registres</li>
                                <li>Gestion des drapeaux (flags)</li>
                            </ul>

                            <h2>Pipeline d'instructions</h2>

                            <p>Le 8086 peut <strong>pr√©-charger jusqu'√† 6 octets</strong> d'instructions pendant que
                                l'EU ex√©cute :</p>

                            <pre><code class="language-asm">; BIU charge les instructions suivantes
; pendant que EU ex√©cute l'instruction actuelle
MOV AX, 10     ; EU ex√©cute, BIU charge les prochaines
ADD BX, 5      ; D√©j√† en queue !
SUB CX, 2      ; D√©j√† en queue !</code></pre>

                            <div class="alert alert-warning">
                                <h4>‚ö†Ô∏è Attention aux sauts !</h4>
                                <p>
                                    Les instructions JMP vident la queue, ce qui ralentit l'ex√©cution. C'est pourquoi
                                    les sauts sont "co√ªteux" en performance.
                                </p>
                            </div>

                            <h2>Organisation m√©moire et segmentation</h2>

                            <h3>Pourquoi la segmentation ?</h3>

                            <p>Le 8086 a un probl√®me : ses registres font 16-bit mais il a besoin d'adresser 1 MB de
                                m√©moire (20-bit) !</p>

                            <table class="table table-bordered">
                                <tr>
                                    <td><strong>Registres 16-bit</strong></td>
                                    <td>Peuvent adresser : 2^16 = 64 KB</td>
                                </tr>
                                <tr>
                                    <td><strong>M√©moire totale</strong></td>
                                    <td>N√©cessite : 2^20 = 1 MB</td>
                                </tr>
                            </table>

                            <p><strong>Solution</strong> : Diviser la m√©moire en <strong>segments de 64 KB</strong> !
                            </p>

                            <h3>Calcul d'adresse physique</h3>

                            <p>Pour acc√©der √† la m√©moire, le 8086 combine un registre de segment et un offset :</p>

                            <pre><code class="language-asm">Adresse Physique = (Segment √ó 16) + Offset
                         = (Segment << 4) + Offset

Exemple :
DS = 1000h
Offset = 0234h
Adresse Physique = (1000h √ó 16) + 0234h
                 = 10000h + 0234h
                 = 10234h</code></pre>

                            <h3>Les 4 segments principaux</h3>

                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Registre</th>
                                        <th>Nom</th>
                                        <th>Usage</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>CS</strong></td>
                                        <td>Code Segment</td>
                                        <td>Stocke le code du programme</td>
                                    </tr>
                                    <tr>
                                        <td><strong>DS</strong></td>
                                        <td>Data Segment</td>
                                        <td>Stocke les donn√©es</td>
                                    </tr>
                                    <tr>
                                        <td><strong>SS</strong></td>
                                        <td>Stack Segment</td>
                                        <td>G√®re la pile</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ES</strong> </td>
                                        <td>Extra Segment</td>
                                        <td>Segment suppl√©mentaire</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h3>Exemple pratique</h3>

                            <pre><code class="language-asm">; Initialiser DS pour acc√©der aux donn√©es
MOV AX, @DATA    ; @DATA = adresse segment donn√©es
MOV DS, AX       ; DS pointe maintenant sur nos donn√©es

; Acc√©der √† une variable
MOV AL, [msg]    ; Adresse = DS:offset(msg)</code></pre>

                            <h2>Bus du 8086</h2>

                            <h3>Bus de donn√©es (16-bit)</h3>
                            <p>Transporte les donn√©es entre CPU et m√©moire. Peut transf√©rer :</p>
                            <ul>
                                <li><strong>1 byte</strong> : Sur adresse paire ou impaire</li>
                                <li><strong>2 bytes (1 word)</strong> : Sur adresse paire en un cycle</li>
                            </ul>

                            <h3>Bus d'adresses (20-bit)</h3>
                            <p>Permet d'adresser 2^20 = <strong>1 048 576 bytes = 1 MB</strong> de m√©moire.</p>

                            <pre><code class="language-asm">Plage d'adresses : 00000h √† FFFFFh (hexad√©cimal)
                    0 √† 1 048 575 (d√©cimal)</code></pre>

                            <h2>Modes de fonctionnement</h2>

                            <h3>Mode Minimum vs Maximum</h3>

                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Mode Minimum</th>
                                        <th>Mode Maximum</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>CPU seul</td>
                                        <td>Plusieurs processeurs</td>
                                    </tr>
                                    <tr>
                                        <td>Syst√®mes simples</td>
                                        <td>Syst√®mes complexes</td>
                                    </tr>
                                    <tr>
                                        <td>PC personnels</td>
                                        <td>Serveurs, multiprocessing</td>
                                    </tr>
                                </tbody>
                            </table>

                            <p>Pour emu8086 et nos programmes, nous utilisons le <strong>mode minimum</strong>.</p>

                            <h2>Flags (Drapeaux)</h2>

                            <p>Le 8086 poss√®de un registre FLAGS de 16-bit avec 9 flags actifs :</p>

                            <table class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Flag</th>
                                        <th>Nom</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>CF</strong></td>
                                        <td>Carry Flag</td>
                                        <td>Retenue pour op√©rations non-sign√©es</td>
                                    </tr>
                                    <tr>
                                        <td><strong>PF</strong></td>
                                        <td>Parity Flag</td>
                                        <td>Parit√© du r√©sultat (pair/impair)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>AF</strong></td>
                                        <td>Auxiliary Flag</td>
                                        <td>Retenue BCD</td>
                                    </tr>
                                    <tr>
                                        <td><strong>ZF</strong></td>
                                        <td>Zero Flag</td>
                                        <td>R√©sultat = 0</td>
                                    </tr>
                                    <tr>
                                        <td><strong>SF</strong></td>
                                        <td>Sign Flag</td>
                                        <td>R√©sultat n√©gatif (bit de signe)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>TF</strong></td>
                                        <td>Trap Flag</td>
                                        <td>Mode pas-√†-pas (debug)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>IF</strong></td>
                                        <td>Interrupt Flag</td>
                                        <td>Activer/d√©sactiver interruptions</td>
                                    </tr>
                                    <tr>
                                        <td><strong>DF</strong></td>
                                        <td>Direction Flag</td>
                                        <td>Direction des op√©rations sur cha√Ænes</td>
                                    </tr>
                                    <tr>
                                        <td><strong>OF</strong></td>
                                        <td>Overflow Flag</td>
                                        <td>D√©bordement sign√©</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h3>Visualiser les flags dans emu8086</h3>

                            <p>Dans emu8086, les flags sont affich√©s en temps r√©el. Testez :</p>

                            <pre><code class="language-asm">MOV AL, 255
ADD AL, 1      ; CF=1 (d√©bordement non-sign√©)
               ; ZF=1 (r√©sultat = 0)
               ; PF=1 (parit√© paire)</code></pre>
                        </section>

                        <aside class="tips alert">
                            <h3>üí° Astuces</h3>
                            <ul>
                                <li>Visualisez la segmentation dans emu8086 (fen√™tre Memory)</li>
                                <li>Observez les flags apr√®s chaque instruction</li>
                                <li>Rappelez-vous : Adresse = (Segment √ó 16) + Offset</li>
                                <li>CS, DS, SS, ES sont TOUJOURS des segments</li>
                                <li>Le pipeline rend les sauts plus lents</li>
                            </ul>
                        </aside>

                        <aside class="common-mistakes alert">
                            <h3>‚ö†Ô∏è Erreurs fr√©quentes</h3>
                            <ul>
                                <li><strong>Oublier d'initialiser DS</strong> : Acc√®s donn√©es incorrect</li>
                                <li><strong>Confondre segment et offset</strong> : MOV DS, 1000h n'est PAS 1000h en
                                    m√©moire</li>
                                <li><strong>Ignorer les flags</strong> : N√©cessaires pour les sauts conditionnels</li>
                                <li><strong>Mauvais calcul d'adresse</strong> : Segment √ó 16, pas √ó 10 !</li>
                            </ul>
                        </aside>

                        <section class="my-5">
                            <h2 class="mb-4">Quiz de r√©vision</h2>
                            <div id="quiz-ch02"></div>
                        </section>

                        <section class="my-5">
                            <h2 class="mb-4">Exercices pratiques</h2>

                            <div class="exercise easy">
                                <div class="exercise-header">
                                    <h3 class="exercise-title">Exercice 1 : Calcul d'adresse physique</h3>
                                    <span class="exercise-difficulty">Facile</span>
                                </div>
                                <div class="exercise-description">
                                    <p>Calculez les adresses physiques :</p>
                                    <ul>
                                        <li>DS = 2000h, Offset = 0100h ‚Üí Adresse physique ?</li>
                                        <li>CS = 1234h, Offset = 5678h ‚Üí Adresse physique ?</li>
                                        <li>SS = FFFFh, Offset = 000Fh ‚Üí Adresse physique ?</li>
                                    </ul>
                                </div>
                                <button class="btn btn-sm btn-outline-primary mt-3 solution-toggle" onclick="toggleSolution('sol-ch02-ex1')">
                                    üëÅÔ∏è Voir la solution
                                </button>
                                <div id="sol-ch02-ex1" class="solution-box" style="display: none;">
                                    <h4>Solution - Calcul d'adresses</h4>
                                    <p><strong>Formule :</strong> Adresse physique = Segment √ó 16 + Offset</p>
<ol>
<li><strong>DS = 2000h, Offset = 0100h</strong>
<pre><code class="language-asm">= 2000h √ó 10h + 0100h
= 20000h + 0100h
= 20100h</code></pre>
</li>
<li><strong>CS = 1234h, Offset = 5678h</strong>
<pre><code class="language-asm">= 1234h √ó 10h + 5678h
= 12340h + 5678h
= 179B8h</code></pre>
</li>
<li><strong>SS = FFFFh, Offset = 000Fh</strong>
<pre><code class="language-asm">= FFFFh √ó 10h + 000Fh
= FFFF0h + 000Fh
= FFFFFh (derni√®re adresse)</code></pre>
</li>
</ol>
                                </div>
                            </div>

                            <div class="exercise medium">
                                <div class="exercise-header">
                                    <h3 class="exercise-title">Exercice 2 : Observer les flags</h3>
                                    <span class="exercise-difficulty">Moyen</span>
                                </div>
                                <div class="exercise-description">
                                    <p>Dans emu8086, cr√©ez un programme qui :</p>
                                    <ul>
                                        <li>Fait ADD de deux nombres qui d√©bordent</li>
                                        <li>Fait SUB qui donne z√©ro</li>
                                        <li>Observez CF, ZF, SF dans la fen√™tre Flags</li>
                                        <li>Notez les valeurs des flags</li>
                                    </ul>
                                </div>
                                <button class="btn btn-sm btn-outline-primary mt-3 solution-toggle" onclick="toggleSolution('sol-ch02-ex2')">
                                    üëÅÔ∏è Voir la solution
                                </button>
                                <div id="sol-ch02-ex2" class="solution-box" style="display: none;">
                                    <h4>Solution - Observer les flags</h4>
                                    <pre><code class="language-asm">.MODEL SMALL
.CODE
MAIN PROC
    ; Test 1 : D√©bordement
    MOV AL, 255
    ADD AL, 1
    ; AL = 0, CF = 1, ZF = 1
    
    ; Test 2 : R√©sultat z√©ro
    MOV AX, 100
    SUB AX, 100
    ; AX = 0, ZF = 1, CF = 0, SF = 0
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN</code></pre>
<p><strong>Observations :</strong></p>
<ul>
<li><strong>CF = 1</strong> : Lors du d√©bordement (255 + 1)</li>
<li><strong>ZF = 1</strong> : R√©sultat = 0</li>
<li><strong>SF = 0/1</strong> : Selon le signe du r√©sultat</li>
</ul>
                                </div>
                            </div>

                            <div class="exercise medium">
                                <div class="exercise-header">
                                    <h3 class="exercise-title">Exercice 3 : Segmentation en pratique</h3>
                                    <span class="exercise-difficulty">Moyen</span>
                                </div>
                                <div class="exercise-description">
                                    <p>√âcrivez un programme qui :</p>
                                    <ul>
                                        <li>D√©clare une variable dans .DATA</li>
                                        <li>Affiche la valeur de DS (utilisez emu8086 debugger)</li>
                                        <li>Calculez l'adresse physique de votre variable</li>
                                        <li>V√©rifiez dans la fen√™tre Memory de emu8086</li>
                                    </ul>
                                </div>
                                <button class="btn btn-sm btn-outline-primary mt-3 solution-toggle" onclick="toggleSolution('sol-ch02-ex3')">
                                    üëÅÔ∏è Voir la solution
                                </button>
                                <div id="sol-ch02-ex3" class="solution-box" style="display: none;">
                                    <h4>Solution - Segmentation pratique</h4>
                                    <pre><code class="language-asm">.MODEL SMALL
.STACK 100h

.DATA
    valeur DW 1234h

.CODE
MAIN PROC
    MOV AX, @DATA
    MOV DS, AX
    
    ; Observer DS dans emu8086
    ; Puis Memory view pour voir la variable
    
    MOV BX, valeur
    
    MOV AH, 4Ch
    INT 21h
MAIN ENDP
END MAIN</code></pre>
<p><strong>Dans emu8086 :</strong></p>
<ol>
<li>Lancez le debugger (F8)</li>
<li>Regardez la valeur de DS</li>
<li>Calculez : DS √ó 10h + offset de valeur</li>
<li>V√©rifiez dans Memory View</li>
</ol>
                                </div>
                            </div>
                        </section>

                        <nav class="chapter-nav">
                            <a href="ch01-introduction.html" class="chapter-nav-btn">‚Üê Pr√©c√©dent : Introduction</a>
                            <a href="ch03-registres.html" class="chapter-nav-btn">Suivant : Registres 16-bit ‚Üí</a>
                        </nav>

                        <div class="text-center my-5">
                            <button id="mark-complete-btn" class="btn btn-success btn-lg">‚úì Marquer ce chapitre comme
                                termin√©</button>
                        </div>
                    </div>
                </article>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2024 Learn2succeed. Tous droits r√©serv√©s.</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="../../../js/main.js"></script>
    <script src="../../../js/progress-tracker.js"></script>
    <script src="../../../js/quiz.js"></script>

    <script>
        const courseId = 'assembly-x86-64';
        const chapterId = 'ch02-architecture';

        const chapters = [
            { id: "ch01-introduction", title: "Introduction" },
            { id: "ch02-architecture", title: "Architecture 8086" },
            { id: "ch03-registres", title: "Registres 16-bit" },
            { id: "ch04-instructions-base", title: "Instructions de base" },
            { id: "ch05-adressage", title: "Modes d'adressage" },
            { id: "ch06-controle", title: "Instructions de contr√¥le" },
            { id: "ch07-pile", title: "La pile" },
            { id: "ch08-procedures", title: "Proc√©dures" },
            { id: "ch09-chaines", title: "Cha√Ænes" },
            { id: "ch10-tableaux", title: "Tableaux" },
            { id: "ch11-interruptions", title: "Interruptions DOS" },
            { id: "ch12-video", title: "Affichage vid√©o" },
            { id: "ch13-ports", title: "Ports" },
            { id: "ch14-debugging", title: "Debugging" },
            { id: "ch15-projets", title: "Projets" }
        ];

        const quizData = {
            title: "Quiz - Architecture 8086",
            course_id: courseId,
            chapter_id: chapterId,
            questions: [
                {
                    question: "Quelle est la taille du bus de donn√©es du 8086 ?",
                    type: "single",
                    options: ["8-bit", "16-bit", "20-bit", "32-bit"],
                    correct: 1,
                    explanation: "Le 8086 a un bus de donn√©es de 16-bit, permettant de transf√©rer 2 octets √† la fois."
                },
                {
                    question: "Quelle est la taille du bus d'adresses ?",
                    type: "single",
                    options: ["16-bit", "20-bit", "24-bit", "32-bit"],
                    correct: 1,
                    explanation: "Le bus d'adresses fait 20-bit, permettant d'adresser 2^20 = 1 MB de m√©moire."
                },
                {
                    question: "Comment calculer l'adresse physique ?",
                    type: "single",
                    options: [
                        "Segment + Offset",
                        "Segment √ó 16 + Offset",
                        "Segment √ó 10 + Offset",
                        "Segment / 16 + Offset"
                    ],
                    correct: 1,
                    explanation: "Adresse physique = (Segment √ó 16) + Offset. On d√©cale le segment de 4 bits √† gauche."
                },
                {
                    question: "Combien de bytes peut contenir un segment ?",
                    type: "single",
                    options: ["16 KB", "32 KB", "64 KB", "1 MB"],
                    correct: 2,
                    explanation: "Un segment peut contenir 64 KB (2^16 bytes) car l'offset est sur 16-bit."
                },
                {
                    question: "Quel registre stocke l'adresse du segment de donn√©es ?",
                    type: "single",
                    options: ["CS", "DS", "SS", "ES"],
                    correct: 1,
                    explanation: "DS (Data Segment) pointe vers le segment contenant les donn√©es du programme."
                },
                {
                    question: "Que fait le pipeline du 8086 ?",
                    type: "single",
                    options: [
                        "Ex√©cute plusieurs instructions en parall√®le",
                        "Pr√©-charge les instructions suivantes",
                        "Acc√©l√®re les calculs",
                        "G√®re la m√©moire"
                    ],
                    correct: 1,
                    explanation: "Le pipeline pr√©-charge jusqu'√† 6 octets d'instructions pendant que l'EU ex√©cute."
                },
                {
                    question: "Quel flag indique un r√©sultat z√©ro ?",
                    type: "single",
                    options: ["CF", "ZF", "SF", "OF"],
                    correct: 1,
                    explanation: "ZF (Zero Flag) est mis √† 1 quand le r√©sultat d'une op√©ration est z√©ro."
                },
                {
                    question: "Quelle est la m√©moire maximale du 8086 ?",
                    type: "single",
                    options: ["64 KB", "256 KB", "1 MB", "4 MB"],
                    correct: 2,
                    explanation: "Avec 20-bit d'adressage, le 8086 peut adresser 2^20 = 1 MB de m√©moire."
                }
            ]
        };

        document.addEventListener('DOMContentLoaded', () => {
            ProgressTracker.markChapterViewed(courseId, chapterId);

            const chapterList = document.getElementById('chapter-list');
            chapters.forEach(chapter => {
                const li = document.createElement('li');
                li.className = 'chapter-item';
                const link = document.createElement('a');
                link.href = `${chapter.id}.html`;
                link.className = 'chapter-link';
                if (chapter.id === chapterId) link.classList.add('active');
                else if (ProgressTracker.isChapterCompleted(courseId, chapter.id)) link.classList.add('completed');
                link.textContent = chapter.title;
                li.appendChild(link);
                chapterList.appendChild(li);
            });

            QuizSystem.createQuiz(quizData, 'quiz-ch02');

            const markCompleteBtn = document.getElementById('mark-complete-btn');
            if (ProgressTracker.isChapterCompleted(courseId, chapterId)) {
                markCompleteBtn.textContent = '‚úì Chapitre termin√©';
                markCompleteBtn.disabled = true;
                markCompleteBtn.classList.remove('btn-success');
                markCompleteBtn.classList.add('btn-outline');
            }

            markCompleteBtn.addEventListener('click', () => {
                ProgressTracker.markChapterComplete(courseId, chapterId);
                alert('F√©licitations ! üéâ');
                location.reload();
            });
        });
    </script>

    <script>
        // Solution toggle function
        function toggleSolution(id) {
            const solution = document.getElementById(id);
            const button = event.target;
            
            if (solution.style.display === 'none') {
                solution.style.display = 'block';
                button.textContent = 'üôà Masquer la solution';
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
            } else {
                solution.style.display = 'none';
                button.textContent = 'üëÅÔ∏è Voir la solution';
                button.classList.remove('btn-primary');
                button.classList.add('btn-outline-primary');
            }
        }
    </script>
    
    <style>
        .solution-box {
            margin-top: 1rem;
            padding: 1.5rem;
            background-color: #f8f9fa;
            border-left: 4px solid #0d6efd;
            border-radius: 0.375rem;
            animation: slideDown 0.3s ease-out;
        }
        
        .solution-box h4 {
            color: #0d6efd;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        
        .solution-box pre {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 1rem;
            margin-top: 0.5rem;
        }
        
        .solution-toggle {
            transition: all 0.2s ease;
        }
        
        .solution-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>

</body>

</html>